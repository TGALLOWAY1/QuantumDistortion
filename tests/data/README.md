# Test Audio Fixtures

This directory contains short, synthetic test fixtures generated by `scripts/generate_test_fixtures.py`.

These fixtures are used for:
- Regression testing of the audio processing pipeline
- Listening tests to verify audio quality
- Performance benchmarking
- Integration tests

All fixtures are generated synthetically using Python + NumPy, making them:
- Easy to version control (script is versioned, not large audio files)
- Reproducible across environments
- Deterministic and consistent

## Expected Files

The following files are generated by `scripts/generate_test_fixtures.py`:

- **`sub_sweep.wav`**: 5 seconds, frequency sweep from ~30 Hz to ~120 Hz. Useful for testing frequency-dependent processing and quantization behavior across the sub-bass range.

- **`wobble_bass.wav`**: 5 seconds, a simple bass tone with LFO-like amplitude modulation. Tests how the pipeline handles time-varying amplitude and bass frequencies.

- **`kick_sub_combo.wav`**: Alternating pattern of short "kick" bursts and sustained sub tones. Tests transient handling and the interaction between percussive and sustained elements.

- **`midrange_growl_like.wav`**: A midrange tone with basic distortion/modulation to mimic a "growl-ish" texture. Tests processing of harmonically rich, modulated signals in the midrange.

## Regenerating Fixtures

To regenerate all fixtures, run:

```bash
python scripts/generate_test_fixtures.py
```

This will overwrite existing fixture files. The script uses deterministic generation, so the output should be identical across runs.

## Regression Testing

### Quick Regression Suite

The `scripts/quick_regression_suite.py` script processes all test fixtures through the Quantum Distortion pipeline and reports null-test metrics (residual RMS in dB) to track changes over time.

**Usage**:
```bash
python scripts/quick_regression_suite.py
```

**With preset**:
```bash
python scripts/quick_regression_suite.py --preset <preset_name>
```

**What it does**:
1. Locates all WAV fixtures in `tests/data/`
2. Processes each through `process_file_to_file` twice:
   - **Single-band mode**: `*_singleband.wav` - original one-band pipeline (full STFT processing)
   - **Multiband mode**: `*_multiband.wav` - low-band time-domain (mono-maker + saturation), high-band spectral (STFT pipeline)
3. Computes residual RMS (in dB) between original and each processed version
4. Prints comparison results showing both single-band and multiband metrics

**Interpreting Results**:
- **More negative dB** = more similar to original / more transparent processing
- **Less negative dB** = more coloration / more processing applied

Typical values:
- Very transparent: < -60 dB
- Moderate processing: -40 to -60 dB
- Heavy processing: > -20 dB

**Multiband Comparison**:
The regression suite compares single-band vs multiband processing to evaluate the impact of the multiband split:
- **Single-band**: Full-band audio goes through the complete STFT pipeline (spectral quantization, distortion, etc.)
- **Multiband**: Audio is split at 300 Hz crossover; low band uses time-domain processing (mono-maker + saturation), high band uses STFT pipeline

**Expected Results**:
- For **bass-heavy fixtures** (`sub_sweep.wav`, `kick_sub_combo.wav`): Multiband should typically show better transparency in the low end (more negative dB) because the low band avoids STFT artifacts and uses time-domain saturation which preserves transient response better.
- For **midrange fixtures** (`midrange_growl_like.wav`): Results may be similar or multiband may show slight differences depending on how much content falls in the low vs high band.
- For **mixed content** (`wobble_bass.wav`): Multiband may show improvements in bass regions while maintaining similar quality in the high end.

The processed outputs are saved to `tests/data/processed/` for manual inspection and listening tests.

